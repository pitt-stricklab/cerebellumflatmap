function ngrProp = readNgrHeader(ngrPath)
%
% Read the header of an ngr file generated by Nanozoomer S60 and validate 
% if it has known values in proper position and return the properties.
%
% HISTORY:
%   1.0 - YYYYMMDD Written by Mitsu
%   1.1 - 20230719 Edited validateNgrType() for a map file of fluorescent 
%                  16-bit monochrome created by NDP.scan 3.4.0.

% <Input>
% ngrPath: (string, char)
%   A path of an ngr file

% <Output>
% ngrProp: (struct)
%   Image properties of the ngr file.
%   ngrProp.height  : image height  
%   ngrProp.width   : image width       
%   ngrProp.colwidth: column width
%   ngrProp.bit     : bit per channel, ex 8, 16
%   ngrProp.channel : the number of channels
%   ngrProp.creator : creator of the ngr, ex NDP.scan
%   ngrProp.offset  : pixel data offset, ex 90, 89
%   ngrProp.type    : (char) string that explains the ngr type


fid = fopen(ngrPath,'r');
        
if fid == -1
    error('Couldn''t open the ngr file.');
end

try

%---------------- BOF ----------------%

%% 1 byte at 0 byte
d0 = fread(fid,1,'uint8');                   % 71 or char 'G' 

if d0 ~= 71
    errorthrow(1,0,'71 (G)',d0);
end

%% 1 byte at 1 byte
d1 = fread(fid,1,'uint8=>char');             % 78 or char 'N'

if d1 ~= 78
    errorthrow(1,1,'78 (N)',d1);
end

%% 1 byte at 2 bytes
d2 = fread(fid,1,'uint8');                   % 0 or char ''

if d2 ~= 0
    errorthrow(1,2,'0',d2);
end

%% 1 byte at 3 bytes
d3 = fread(fid,1,'uint8');                   % 16

if d3 ~= 16
    errorthrow(1,3,'16',d3);
end

%% 4 bytes at 4 bytes
width    = fread(fid,1,'uint32');            % width 

%% 4 bytes at 8 bytes
height   = fread(fid,1,'uint32');            % height

%% 4 bytes at 12 bytes
colwidth = fread(fid,1,'uint32');            % column width

%                        | 32 bit x 1 |
% -----------------------|------------|
% Brightfield            |    1792    |
% Brightfield map        |     224    |
% Brightfield map 2      |     112    |
% Fluorescent  8-bit     |     896    |
% Fluorescent  8-bit map |     112    |
% Fluorescent 16-bit     |     896    |
% Fluorescent 16-bit map |     112    |
% Brightfield  2.0HT     |    1920    |
% Brightfield  2.0HT map |     240    |

if isempty(colwidth)
    % In some older AIFs, colwidth is empty.
    errorthrow(4,12,'noempty',colwidth);
end

% See the bottom validation.

%% 4 bytes at 16 bytes
d16 = fread(fid,1,'uint32');                 % another column width?

% in diff. interpret. -> |  8 bit x 4   | 16 bit x 2 | 32 bit x 1 |
% -----------------------|--------------|------------|------------|
% Brightfield            |  64, 5, 0, 0 |  1344, 0   |    1344    |
% Brightfield map        | 168, 0, 0, 0 |   168, 0   |     168    |
% Brightfield map 2      |  84, 0, 0, 0 |    84, 0   |      84    |
% Fluorescent  8-bit     | 128, 3, 0, 0 |   896, 0   |     896    |
% Fluorescent  8-bit map | 112, 0, 0, 0 |   112, 0   |     112    |
% Fluorescent 16-bit     | 128, 3, 0, 0 |   896, 0   |     896    |
% Fluorescent 16-bit map | 112, 0, 0, 0 |   112, 0   |     112    |
% Brightfield  2.0HT     |   0, 1, 0, 0 |   256, 0   |     256    |
% Brightfield  2.0HT map |  32, 0, 0, 0 |    32, 0   |      32    |

if isempty(d16)
    % In some older AIFs, d16 is empty.
    errorthrow(4,16,'noempty',d16);
end

% See the bottom validation.

%% 4 bytes at 20 bytes
d20 = fread(fid,1,'uint32');                 % creator string offset 64?

% in diff. interpret. -> |  8 bit x 4  | 16 bit x 2 | 32 bit x 1 |
% -----------------------|-------------|------------|------------|
% Brightfield            | 64, 0, 0, 0 |   64, 0    |     64     |
% Brightfield map        | 64, 0, 0, 0 |   64, 0    |     64     |
% Brightfield map 2      | 64, 0, 0, 0 |   64, 0    |     64     |
% Fluorescent  8-bit     | 64, 0, 0, 0 |   64, 0    |     64     |
% Fluorescent  8-bit map | 64, 0, 0, 0 |   64, 0    |     64     |
% Fluorescent 16-bit     | 64, 0, 0, 0 |   64, 0    |     64     |
% Fluorescent 16-bit map | 64, 0, 0, 0 |   64, 0    |     64     |
% Brightfield  2.0HT     | 64, 0, 0, 0 |   64, 0    |     64     |
% Brightfield  2.0HT map | 64, 0, 0, 0 |   64, 0    |     64     |

if d20 ~= 64
    errorthrow(4,20,'64',d20);
end

%% 4 bytes at 24 bytes
offset = fread(fid,1,'uint32');              % pixel data offset 90, 89, and so on
                  
% NOTE:
% This depends on the string length of the NDP.scan version

if isempty(offset)
    % In some older AIFs, d24 is empty.
    errorthrow(4,24,'noempty',offset);
end

%% 4 bytes at 28 bytes
d28 = fread(fid,1,'uint32');                 % different value in different filter

% in diff. interpret. -> |     8 bit x 4    |  16 bit x 2  | 32 bit x 1 |
% -----------------------|------------------|--------------|------------|
% Brightfield            |  58,   4, 57, 66 |  1082, 16953 | 1111032890 |
% Brightfield map        |  58,   4, 57, 66 |  1082, 16953 | 1111032890 |
% Brightfield map 2      |                  |              |            |
% Fluorescent  8-bit     | 165, 223,  6,  6 | 57253,  1542 |  101113765 |
% Fluorescent  8-bit map | 165, 223,  6,  6 | 57253,  1542 |  101113765 |
% Fluorescent 16-bit     | 227, 231, 96, 82 | 59363, 21088 | 1382082531 |
% Fluorescent 16-bit map | 227, 231, 96, 82 | 59363, 21088 | 1382082531 |
% Brightfield  2.0HT     |                  |              |            |
% Brightfield  2.0HT map |                  |              |            |

%% 4 bytes at 32 bytes
d32 = fread(fid,1,'uint32');                 % always zero?

if d32 ~= 0
    errorthrow(4,32,'0',d32);
end

%% 2 bytes at 36 bytes
d36 = fread(fid,1,'uint16');                 % channel+1?

% in diff. interpret. -> | 8 bit x 2 | 16 bit x 1 |
% -----------------------|-----------|------------|
% Brightfield            |    4, 0   |      4     | 
% Brightfield map        |    4, 0   |      4     | 
% Brightfield map 2      |    4, 0   |      4     | 
% Fluorescent  8-bit     |    4, 0   |      4     | 
% Fluorescent  8-bit map |    4, 0   |      4     | 
% Fluorescent 16-bit     |    2, 0   |      2     | 
% Fluorescent 16-bit map |    2, 0   |      2     |
% Brightfield  2.0HT     |    4, 0   |      4     | 
% Brightfield  2.0HT map |    4, 0   |      4     |

if isempty(d36)
    % In some older AIFs, d36 is empty.
    errorthrow(2,36,'noempty',d36);
end

% See the bottom validation.

%% 1 byte at 38 bytes
d38 = fread(fid,1,'uint8');                  % bitdepth?

%                        | 8 bit x 1 |
% -----------------------|-----------|
% Brightfield            |    24     |
% Brightfield map        |    24     |
% Brightfield map 2      |    24     |
% Fluorescent  8-bit     |    24     |
% Fluorescent  8-bit map |    24     |
% Fluorescent 16-bit     |    16     |
% Fluorescent 16-bit map |    16     |
% Brightfield  2.0HT     |    24     |
% Brightfield  2.0HT map |    24     |

if isempty(d38)
    % In some older AIFs, d38 is empty.
    errorthrow(1,38,'noempty',d38);
end

% See the bottom validation.

%% 25 bytes at 39 bytes
d39 = fread(fid,25,'uint8');                 % always zeros?

%                        | 8 bit x 25 |
% -----------------------|------------|
% Brightfield            |   0 x 25   |
% Brightfield map        |   0 x 25   |
% Brightfield map 2      |   0 x 25   |
% Fluorescent  8-bit     |   0 x 25   |
% Fluorescent  8-bit map |   0 x 25   |
% Fluorescent 16-bit     |   0 x 25   |
% Fluorescent 16-bit map |   0 x 25   |
% Brightfield  2.0HT     |   0 x 25   |
% Brightfield  2.0HT map |   0 x 25   |

if any(d39)
    errorthrow(25,39,'0 x 25',d39);
end

%% 25 (24) bytes at 64 bytes
creator = fread(fid,[1,offset-64-1],'uint8=>char'); % '#CREATOR: NDP.scan 3.2.17'

% NOTE:
% The string length depends on the NDP.scan version. (char, 1 x N)

%% 1 byte at 89 (88) bytes
d89 = fread(fid, 1,'uint8');                    % always zero?

if d89 ~= 0
    errorthrow(1,89,'0',d89);
end

%% Start pixel data from 90 (89) bytes

% fread(fid,10,'uint8');

%% Check if it has a valid combination of values and determine the type of ngr

type = validateNgrType(colwidth,d16,d36,d38);

%% Store properties in a struct

channel = d36-1;
bit     = d38/channel; % bit per channel

ngrProp.height   = height;
ngrProp.width    = width;
ngrProp.colwidth = colwidth;
ngrProp.bit      = bit;
ngrProp.channel  = channel;
ngrProp.creator  = creator;
ngrProp.offset   = offset;
ngrProp.type     = type;

%% Check if there is no extra data after the entire pixel data

% Move to the end of the pixel data using the assumed bit and channel
fseek(fid,offset+height*width*channel*bit/8,'bof');

% Read additional 1-byte (8 bit)
fread(fid,1);

% Check if it reached EOF by the additional 1-byte
status = feof(fid);

% Error if there is remaining data
if ~status
    error([...
    'There are some unknown data after the pixel data.' newline...
    'It is also possible that the header has not been read correctly.'...
    ]);
end

%% End

fclose(fid);

catch ME
    fclose(fid);
    rethrow(ME);
end

end


function errorthrow(dataSize,place,validValueStr,actValue)

    error(...
    '%d byte(s) data at %d byte(s) later from BOF must be %s but was %s.' ...
    ,...
    dataSize,place,validValueStr,num2str(actValue));

end


function type = validateNgrType(colwidth,d16,d36,d38)

    % Check if it has valid combination of values and determine the type
    
    if     colwidth == 1792 && d16 == 1344 && d36 == 4 && d38 == 24
        type = 'Brightfield 24-bit RGB';
    elseif colwidth ==  224 && d16 ==  168 && d36 == 4 && d38 == 24
        type = 'Brightfield 24-bit RGB map';
    elseif colwidth ==  112 && d16 ==   84 && d36 == 4 && d38 == 24
        type = 'Brightfield 24-bit RGB map older version (?)';
    elseif colwidth ==  896 && d16 ==  896 && d36 == 4 && d38 == 24
        type = 'Fluorescent 24-bit grayscale';
    elseif colwidth ==  112 && d16 ==  112 && d36 == 4 && d38 == 24
        type = 'Fluorescent 24-bit grayscale map';
    elseif colwidth ==  896 && d16 ==  896 && d36 == 2 && d38 == 16
        type = 'Fluorescent 16-bit monochrome';
    elseif colwidth ==  112 && d16 ==  112 && d36 == 2 && d38 == 16
        type = 'Fluorescent 16-bit monochrome map';
    elseif colwidth ==   56 && d16 ==   56 && d36 == 2 && d38 == 16
        type = 'Fluorescent 16-bit monochrome map (NDP.scan 3.4.0)';
    elseif colwidth == 1920 && d16 ==  256 && d36 == 4 && d38 == 24
        type = 'Brightfield 24-bit RGB 2.0HT';
    elseif colwidth ==  240 && d16 ==   32 && d36 == 4 && d38 == 24
        type = 'Brightfield 24-bit RGB 2.0HT map';
    elseif colwidth ==    1 && d16 == 1344 && d36 == 4 && d38 == 24
        type = 'Brightfield 24-bit RGB AIF';
    elseif colwidth ==    1 && d16 ==  896 && d36 == 2 && d38 == 16
        type = 'Fluorescent 16-bit monochrome AIF';    
    else
        error([...
        'Unknown combination\n' ...
        '  colwidth:    %d\n'   ...
        '  colwidth(?): %d\n'   ...
        '  ch+1(?):     %d\n'   ...
        '  bitdepth(?): %d\n'   ...
        ], ...
        colwidth,d16,d36,d38);
    end
    
end